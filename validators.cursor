/**
 * validators.cursor
 * 
 * Purpose: Validation functions for roster assignments, permissions, and business rules
 * 
 * Run notes:
 * - All validators return structured results with errors/warnings
 * - Permission checks are used in API routes and UI components
 * - Import these functions in API routes and use in middleware
 * - Unit tests are provided in tests.cursor
 */

import {
  User,
  Role,
  Roster,
  RosterSlot,
  StoreSettings,
  Permission,
  PermissionCheckResult,
  ValidationResult,
  ValidationError,
  DeleteUserResult,
  DayOfWeek,
  ShiftType,
  ExperienceLevel
} from './schema';

// ============================================================================
// Roster Validation
// ============================================================================

/**
 * Validates roster assignments against business rules
 * 
 * Rules checked:
 * - No staff assigned to multiple shifts on the same day
 * - Shift duration is exactly 9 hours
 * - Minimum staff per shift requirement
 * - Staff not assigned on their week-off days
 * - Experience level matches task requirements
 * - No overlapping shifts for same user
 */
export function validateRosterAssignments(
  roster: Roster,
  storeSettings: StoreSettings,
  allUsers: User[],
  allRosters: Roster[] // For checking conflicts across rosters
): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: string[] = [];

  // Check minimum staff requirement
  if (roster.slots.length < storeSettings.minStaffPerShift) {
    errors.push({
      field: 'slots',
      message: `Minimum ${storeSettings.minStaffPerShift} staff required per shift`,
      code: 'MIN_STAFF_NOT_MET'
    });
  }

  // Check maximum staff requirement
  if (roster.slots.length > storeSettings.maxStaffPerShift) {
    errors.push({
      field: 'slots',
      message: `Maximum ${storeSettings.maxStaffPerShift} staff allowed per shift`,
      code: 'MAX_STAFF_EXCEEDED'
    });
  }

  // Create user map for quick lookup
  const userMap = new Map(allUsers.map(u => [u.id, u]));

  // Check each slot
  const userSlotsOnDate = new Map<string, RosterSlot[]>();
  const date = new Date(roster.date);
  const dayOfWeek = date.getDay() as DayOfWeek;

  roster.slots.forEach(slot => {
    const user = userMap.get(slot.userId);
    if (!user) {
      errors.push({
        field: `slot-${slot.id}`,
        message: `User ${slot.userId} not found`,
        code: 'USER_NOT_FOUND'
      });
      return;
    }

    // Check week-off
    if (user.weekOffs.includes(dayOfWeek)) {
      errors.push({
        field: `slot-${slot.id}`,
        message: `${user.firstName} ${user.lastName} has a week-off on this day`,
        code: 'WEEK_OFF_VIOLATION'
      });
    }

    // Check shift duration (should be 9 hours)
    const start = parseTime(slot.startTime);
    const end = parseTime(slot.endTime);
    const duration = (end - start + (end < start ? 24 : 0)) / 60; // Convert to hours
    if (Math.abs(duration - 9) > 0.1) {
      errors.push({
        field: `slot-${slot.id}`,
        message: `Shift duration must be exactly 9 hours (got ${duration} hours)`,
        code: 'INVALID_SHIFT_DURATION'
      });
    }

    // Track user slots on this date
    if (!userSlotsOnDate.has(slot.userId)) {
      userSlotsOnDate.set(slot.userId, []);
    }
    userSlotsOnDate.get(slot.userId)!.push(slot);
  });

  // Check for duplicate assignments on same date
  userSlotsOnDate.forEach((slots, userId) => {
    if (slots.length > 1) {
      const user = userMap.get(userId)!;
      errors.push({
        field: 'slots',
        message: `${user.firstName} ${user.lastName} is assigned to multiple slots on ${roster.date}`,
        code: 'DUPLICATE_ASSIGNMENT'
      });
    }
  });

  // Check for conflicts with other rosters on the same date
  allRosters.forEach(otherRoster => {
    if (otherRoster.id === roster.id || otherRoster.date !== roster.date) {
      return;
    }

    roster.slots.forEach(slot => {
      const conflictingSlot = otherRoster.slots.find(s => s.userId === slot.userId);
      if (conflictingSlot) {
        const user = userMap.get(slot.userId)!;
        errors.push({
          field: `slot-${slot.id}`,
          message: `${user.firstName} ${user.lastName} is already assigned to ${otherRoster.shiftType} shift on ${roster.date}`,
          code: 'SHIFT_CONFLICT'
        });
      }
    });
  });

  // Coverage validation
  const filledSlots = roster.slots.filter(s => s.userId && s.status !== 'cancelled').length;
  const coveragePercentage = (filledSlots / storeSettings.minStaffPerShift) * 100;
  
  if (coveragePercentage < 100) {
    warnings.push(`Coverage is ${coveragePercentage.toFixed(0)}% (${filledSlots}/${storeSettings.minStaffPerShift} required)`);
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings: warnings.length > 0 ? warnings : undefined
  };
}

/**
 * Helper function to parse time string (HH:mm) to minutes since midnight
 */
function parseTime(timeStr: string): number {
  const [hours, minutes] = timeStr.split(':').map(Number);
  return hours * 60 + minutes;
}

// ============================================================================
// Permission Validation
// ============================================================================

/**
 * Checks if a user can perform a specific action
 * 
 * @param userId - ID of the user requesting the action
 * @param action - The permission being checked
 * @param target - Optional target entity (e.g., user being modified)
 * @param user - The requesting user object (with role populated)
 * @param targetUser - Optional target user object (for user-specific checks)
 * @param storeSettings - Store settings for permission overrides
 */
export function canPerformAction(
  userId: string,
  action: Permission,
  target: { type: 'user' | 'role' | 'roster'; id?: string } | null,
  user: User & { role?: Role },
  targetUser?: User & { role?: Role },
  storeSettings?: StoreSettings
): PermissionCheckResult {
  if (!user.role) {
    return {
      allowed: false,
      reason: 'User role not found',
      requiredPermission: action
    };
  }

  const role = user.role;

  // Store Manager has all permissions
  if (role.name === 'Store Manager' || role.permissions.includes(Permission.CRUD_USER)) {
    // Special checks for SM-specific actions
    if (action === Permission.DELETE_SM_USER || action === Permission.DEMOTE_SM_USER) {
      // Even SM should confirm before deleting/demoting another SM
      return {
        allowed: true,
        reason: 'Store Manager can perform this action (confirmation required)'
      };
    }
    return { allowed: true };
  }

  // Check if role has the permission
  if (role.permissions.includes(action)) {
    // Additional checks for specific actions
    if (action === Permission.CRUD_USER && target?.type === 'user' && targetUser) {
      return canModifyUser(user, targetUser, storeSettings);
    }
    return { allowed: true };
  }

  // Check store settings overrides for SI
  if (role.name === 'Shift In Charge' && storeSettings) {
    if (storeSettings.siPermissions.includes(action)) {
      if (action === Permission.CRUD_USER && target?.type === 'user' && targetUser) {
        return canModifyUser(user, targetUser, storeSettings);
      }
      return { allowed: true };
    }
  }

  return {
    allowed: false,
    reason: `Role "${role.name}" does not have permission "${action}"`,
    requiredPermission: action
  };
}

/**
 * Checks if a user can modify another user
 */
function canModifyUser(
  requestingUser: User & { role?: Role },
  targetUser: User & { role?: Role },
  storeSettings?: StoreSettings
): PermissionCheckResult {
  const requestingRole = requestingUser.role;
  const targetRole = targetUser.role;

  if (!requestingRole || !targetRole) {
    return {
      allowed: false,
      reason: 'User roles not found'
    };
  }

  // SM can modify anyone
  if (requestingRole.name === 'Store Manager') {
    return { allowed: true };
  }

  // SI cannot modify SM users
  if (requestingRole.name === 'Shift In Charge' && targetRole.name === 'Store Manager') {
    if (storeSettings?.siCanModifySM) {
      return {
        allowed: true,
        reason: 'SI can modify SM (override enabled in settings)'
      };
    }
    return {
      allowed: false,
      reason: 'Shift In Charge cannot modify Store Manager accounts'
    };
  }

  // SI can modify staff and ad-hoc PP
  if (requestingRole.name === 'Shift In Charge') {
    if (targetRole.name === 'Picker Packer (Ad-Hoc)' || targetRole.name === 'Picker Packer (Warehouse)') {
      return { allowed: true };
    }
    // SI can modify other staff (IE, etc.) but not SI or SM
    if (targetRole.name !== 'Shift In Charge' && targetRole.name !== 'Store Manager') {
      return { allowed: true };
    }
  }

  return {
    allowed: false,
    reason: `User role "${requestingRole.name}" cannot modify "${targetRole.name}"`
  };
}

// ============================================================================
// User Deletion Validation
// ============================================================================

/**
 * Checks if a user can be deleted and returns impacted rosters
 * 
 * @param userId - ID of the user to delete
 * @param requestingUserId - ID of the user requesting deletion
 * @param allUsers - All users in the system
 * @param allRosters - All rosters (to find future assignments)
 * @param storeSettings - Store settings
 */
export function canDeleteUser(
  userId: string,
  requestingUserId: string,
  allUsers: (User & { role?: Role })[],
  allRosters: Roster[],
  storeSettings?: StoreSettings
): DeleteUserResult {
  const userToDelete = allUsers.find(u => u.id === userId);
  const requestingUser = allUsers.find(u => u.id === requestingUserId);

  if (!userToDelete || !requestingUser) {
    return {
      allowed: false,
      reason: 'User not found',
      impactedRosters: [],
      canReassign: false
    };
  }

  // Check permission
  const permissionCheck = canPerformAction(
    requestingUserId,
    Permission.CRUD_USER,
    { type: 'user', id: userId },
    requestingUser,
    userToDelete,
    storeSettings
  );

  if (!permissionCheck.allowed) {
    return {
      allowed: false,
      reason: permissionCheck.reason || 'Permission denied',
      impactedRosters: [],
      canReassign: false
    };
  }

  // Prevent deleting the last SM
  if (userToDelete.role?.name === 'Store Manager') {
    const smUsers = allUsers.filter(
      u => u.role?.name === 'Store Manager' && u.isActive && !u.deletedAt
    );
    if (smUsers.length <= 1) {
      return {
        allowed: false,
        reason: 'Cannot delete the last Store Manager. At least one SM must exist.',
        impactedRosters: [],
        canReassign: false
      };
    }
  }

  // Find future roster assignments
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  const impactedRosters: DeleteUserResult['impactedRosters'] = [];
  
  allRosters.forEach(roster => {
    const rosterDate = new Date(roster.date);
    rosterDate.setHours(0, 0, 0, 0);
    
    if (rosterDate >= today && roster.status !== 'archived') {
      const userSlots = roster.slots.filter(s => s.userId === userId);
      userSlots.forEach(slot => {
        impactedRosters.push({
          rosterId: roster.id,
          date: roster.date,
          shiftType: roster.shiftType,
          slotId: slot.id
        });
      });
    }
  });

  return {
    allowed: true,
    impactedRosters,
    canReassign: impactedRosters.length > 0
  };
}

// ============================================================================
// Role Deletion Validation
// ============================================================================

/**
 * Checks if a role can be deleted
 */
export function canDeleteRole(
  roleId: string,
  allRoles: Role[],
  allUsers: User[]
): { allowed: boolean; reason?: string; affectedUsers: User[] } {
  const role = allRoles.find(r => r.id === roleId);
  
  if (!role) {
    return {
      allowed: false,
      reason: 'Role not found',
      affectedUsers: []
    };
  }

  // System roles cannot be deleted
  if (role.isSystemRole) {
    return {
      allowed: false,
      reason: 'System roles cannot be deleted',
      affectedUsers: []
    };
  }

  // Check if role is in use
  const affectedUsers = allUsers.filter(u => u.roleId === roleId && !u.deletedAt);
  
  if (affectedUsers.length > 0) {
    return {
      allowed: false,
      reason: `Cannot delete role "${role.name}" because ${affectedUsers.length} user(s) are assigned to it. Please reassign users first.`,
      affectedUsers
    };
  }

  return {
    allowed: true,
    affectedUsers: []
  };
}

// ============================================================================
// Week-Off Validation
// ============================================================================

/**
 * Validates week-off assignments
 */
export function validateWeekOffs(weekOffs: number[]): ValidationResult {
  const errors: ValidationError[] = [];

  // Check valid day numbers (0-6)
  const invalidDays = weekOffs.filter(d => d < 0 || d > 6 || !Number.isInteger(d));
  if (invalidDays.length > 0) {
    errors.push({
      field: 'weekOffs',
      message: `Invalid day numbers: ${invalidDays.join(', ')}. Must be 0-6 (Sunday-Saturday)`,
      code: 'INVALID_WEEK_OFF_DAYS'
    });
  }

  // Check for duplicates
  const uniqueDays = new Set(weekOffs);
  if (uniqueDays.size !== weekOffs.length) {
    errors.push({
      field: 'weekOffs',
      message: 'Duplicate week-off days found',
      code: 'DUPLICATE_WEEK_OFFS'
    });
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

// ============================================================================
// Email Validation
// ============================================================================

/**
 * Validates email format
 */
export function validateEmail(email: string): ValidationResult {
  const errors: ValidationError[] = [];
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

  if (!email || !emailRegex.test(email)) {
    errors.push({
      field: 'email',
      message: 'Invalid email format',
      code: 'INVALID_EMAIL'
    });
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

// ============================================================================
// Employee ID Validation
// ============================================================================

/**
 * Validates employee ID uniqueness
 */
export function validateEmployeeId(
  employeeId: string,
  existingUsers: User[],
  excludeUserId?: string
): ValidationResult {
  const errors: ValidationError[] = [];

  if (!employeeId || employeeId.trim().length === 0) {
    errors.push({
      field: 'employeeId',
      message: 'Employee ID is required',
      code: 'EMPLOYEE_ID_REQUIRED'
    });
    return { valid: false, errors };
  }

  const duplicate = existingUsers.find(
    u => u.employeeId.toLowerCase() === employeeId.toLowerCase() && 
         u.id !== excludeUserId && 
         !u.deletedAt
  );

  if (duplicate) {
    errors.push({
      field: 'employeeId',
      message: `Employee ID "${employeeId}" already exists`,
      code: 'EMPLOYEE_ID_DUPLICATE'
    });
  }

  return {
    valid: errors.length === 0,
    errors
  };
}
