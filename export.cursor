/**
 * export.cursor
 * 
 * Purpose: CSV and PDF export utilities for rosters
 * 
 * Run notes:
 * - CSV export uses simple string concatenation (no external library needed)
 * - PDF export requires jsPDF library: npm install jspdf
 * - For production, consider using server-side PDF generation (Puppeteer, PDFKit)
 * - Import types from './schema'
 */

import {
  Roster,
  User,
  ExportOptions,
  RosterSlot
} from './schema';

// ============================================================================
// CSV Export
// ============================================================================

/**
 * Export rosters to CSV format
 */
export function exportRostersToCSV(
  rosters: Roster[],
  users: User[],
  options: ExportOptions
): string {
  const lines: string[] = [];
  const userMap = new Map(users.map(u => [u.id, u]));

  // Header row
  const headers = [
    'Date',
    'Shift',
    'Employee ID',
    'Name',
    'Role',
    'Start Time',
    'End Time',
    'Status'
  ];

  if (options.includeContactInfo) {
    headers.push('Email', 'Phone');
  }

  if (options.includeTasks) {
    headers.push('Tasks');
  }

  if (options.includeMetadata) {
    headers.push('Created At', 'Published At', 'Created By');
  }

  lines.push(headers.join(','));

  // Data rows
  rosters.forEach(roster => {
    roster.slots.forEach(slot => {
      const user = userMap.get(slot.userId);
      if (!user) return;

      const row: string[] = [
        roster.date,
        roster.shiftType,
        user.employeeId,
        `"${user.firstName} ${user.lastName}"`,
        user.role?.name || '',
        slot.startTime,
        slot.endTime,
        slot.status
      ];

      if (options.includeContactInfo) {
        row.push(user.email, user.phone || '');
      }

      if (options.includeTasks) {
        row.push(`"${slot.assignedTasks.join(', ')}"`);
      }

      if (options.includeMetadata) {
        row.push(
          roster.createdAt.toISOString(),
          roster.publishedAt?.toISOString() || '',
          roster.createdBy
        );
      }

      lines.push(row.join(','));
    });
  });

  return lines.join('\n');
}

/**
 * Download CSV file in browser
 */
export function downloadCSV(content: string, filename: string = 'rosters.csv'): void {
  const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  
  link.setAttribute('href', url);
  link.setAttribute('download', filename);
  link.style.visibility = 'hidden';
  
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  URL.revokeObjectURL(url);
}

// ============================================================================
// PDF Export
// ============================================================================

/**
 * Export rosters to PDF format
 * Requires jsPDF: npm install jspdf
 */
export async function exportRostersToPDF(
  rosters: Roster[],
  users: User[],
  options: ExportOptions
): Promise<Blob> {
  // Dynamic import to avoid requiring jsPDF at build time if not used
  const { jsPDF } = await import('jspdf');
  
  const doc = new jsPDF();
  const userMap = new Map(users.map(u => [u.id, u]));
  let yPosition = 20;
  const pageHeight = doc.internal.pageSize.height;
  const margin = 20;
  const lineHeight = 7;

  rosters.forEach((roster, rosterIndex) => {
    // Add new page for each roster (except first)
    if (rosterIndex > 0) {
      doc.addPage();
      yPosition = 20;
    }

    // Title
    doc.setFontSize(16);
    doc.text(`Roster: ${roster.date} - ${roster.shiftType}`, margin, yPosition);
    yPosition += 10;

    // Coverage info
    doc.setFontSize(10);
    doc.text(
      `Coverage: ${roster.coverage.filledSlots}/${roster.coverage.minRequiredStaff} (${roster.coverage.coveragePercentage.toFixed(0)}%)`,
      margin,
      yPosition
    );
    yPosition += 10;

    // Table header
    doc.setFontSize(9);
    doc.setFont(undefined, 'bold');
    let xPosition = margin;
    
    doc.text('Employee ID', xPosition, yPosition);
    xPosition += 30;
    doc.text('Name', xPosition, yPosition);
    xPosition += 50;
    doc.text('Role', xPosition, yPosition);
    xPosition += 30;
    doc.text('Time', xPosition, yPosition);
    xPosition += 30;
    
    if (options.includeTasks) {
      doc.text('Tasks', xPosition, yPosition);
      xPosition += 40;
    }

    yPosition += 5;
    doc.setLineWidth(0.5);
    doc.line(margin, yPosition, 190, yPosition);
    yPosition += 5;

    // Table rows
    doc.setFont(undefined, 'normal');
    roster.slots.forEach(slot => {
      // Check if we need a new page
      if (yPosition > pageHeight - 30) {
        doc.addPage();
        yPosition = 20;
      }

      const user = userMap.get(slot.userId);
      if (!user) return;

      xPosition = margin;
      doc.text(user.employeeId, xPosition, yPosition);
      xPosition += 30;
      doc.text(`${user.firstName} ${user.lastName}`, xPosition, yPosition);
      xPosition += 50;
      doc.text(user.role?.name || '', xPosition, yPosition);
      xPosition += 30;
      doc.text(`${slot.startTime} - ${slot.endTime}`, xPosition, yPosition);
      xPosition += 30;

      if (options.includeTasks) {
        const tasksText = slot.assignedTasks.join(', ');
        // Truncate if too long
        const truncatedTasks = doc.splitTextToSize(tasksText, 40);
        doc.text(truncatedTasks, xPosition, yPosition);
      }

      yPosition += lineHeight;
    });

    // Footer
    if (options.includeMetadata) {
      yPosition += 5;
      doc.setFontSize(8);
      doc.setFont(undefined, 'italic');
      doc.text(
        `Created: ${roster.createdAt.toLocaleString()} | Published: ${roster.publishedAt?.toLocaleString() || 'Not published'}`,
        margin,
        yPosition
      );
    }
  });

  return doc.output('blob');
}

/**
 * Download PDF file in browser
 */
export function downloadPDF(blob: Blob, filename: string = 'rosters.pdf'): void {
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  
  link.setAttribute('href', url);
  link.setAttribute('download', filename);
  link.style.visibility = 'hidden';
  
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  URL.revokeObjectURL(url);
}

// ============================================================================
// Combined Export Function
// ============================================================================

/**
 * Main export function that handles both CSV and PDF
 */
export async function exportRosters(
  rosters: Roster[],
  users: User[],
  options: ExportOptions
): Promise<void> {
  if (options.format === 'csv') {
    const csvContent = exportRostersToCSV(rosters, users, options);
    downloadCSV(csvContent, `rosters-${options.dateRange.start}-${options.dateRange.end}.csv`);
  } else if (options.format === 'pdf') {
    const pdfBlob = await exportRostersToPDF(rosters, users, options);
    downloadPDF(pdfBlob, `rosters-${options.dateRange.start}-${options.dateRange.end}.pdf`);
  } else {
    throw new Error(`Unsupported export format: ${options.format}`);
  }
}

// ============================================================================
// Printable Roster HTML (Alternative to PDF)
// ============================================================================

/**
 * Generate printable HTML for roster
 * Can be used with window.print() or converted to PDF server-side
 */
export function generatePrintableRosterHTML(
  roster: Roster,
  users: User[]
): string {
  const userMap = new Map(users.map(u => [u.id, u]));

  return `
    <!DOCTYPE html>
    <html>
      <head>
        <title>Roster - ${roster.date} - ${roster.shiftType}</title>
        <style>
          body { font-family: Arial, sans-serif; padding: 20px; }
          h1 { margin-bottom: 10px; }
          table { width: 100%; border-collapse: collapse; margin-top: 20px; }
          th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
          th { background-color: #f2f2f2; font-weight: bold; }
          @media print {
            body { padding: 0; }
            .no-print { display: none; }
          }
        </style>
      </head>
      <body>
        <h1>Roster: ${roster.date} - ${roster.shiftType} Shift</h1>
        <p>Coverage: ${roster.coverage.filledSlots}/${roster.coverage.minRequiredStaff} (${roster.coverage.coveragePercentage.toFixed(0)}%)</p>
        <table>
          <thead>
            <tr>
              <th>Employee ID</th>
              <th>Name</th>
              <th>Role</th>
              <th>Start Time</th>
              <th>End Time</th>
              <th>Tasks</th>
            </tr>
          </thead>
          <tbody>
            ${roster.slots.map(slot => {
              const user = userMap.get(slot.userId);
              if (!user) return '';
              return `
                <tr>
                  <td>${user.employeeId}</td>
                  <td>${user.firstName} ${user.lastName}</td>
                  <td>${user.role?.name || ''}</td>
                  <td>${slot.startTime}</td>
                  <td>${slot.endTime}</td>
                  <td>${slot.assignedTasks.join(', ')}</td>
                </tr>
              `;
            }).join('')}
          </tbody>
        </table>
        <p class="no-print" style="margin-top: 20px;">
          <button onclick="window.print()">Print</button>
        </p>
      </body>
    </html>
  `;
}

/**
 * Open printable roster in new window
 */
export function printRoster(roster: Roster, users: User[]): void {
  const html = generatePrintableRosterHTML(roster, users);
  const printWindow = window.open('', '_blank');
  if (printWindow) {
    printWindow.document.write(html);
    printWindow.document.close();
    printWindow.onload = () => {
      printWindow.print();
    };
  }
}
