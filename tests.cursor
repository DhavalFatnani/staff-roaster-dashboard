/**
 * tests.cursor
 * 
 * Purpose: Unit tests and E2E test specifications
 * 
 * Run notes:
 * - Tests use Jest and React Testing Library
 * - Install: npm install --save-dev jest @testing-library/react @testing-library/jest-dom
 * - Run tests: npm test
 * - E2E tests can use Playwright or Cypress
 */

import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import {
  validateRosterAssignments,
  canPerformAction,
  canDeleteUser,
  canDeleteRole,
  validateEmail,
  validateEmployeeId,
  validateWeekOffs
} from './validators';
import {
  User,
  Role,
  Roster,
  StoreSettings,
  Permission,
  ExperienceLevel,
  PPType,
  ShiftType
} from './schema';

// ============================================================================
// Validator Unit Tests
// ============================================================================

describe('validateRosterAssignments', () => {
  let storeSettings: StoreSettings;
  let allUsers: User[];
  let allRosters: Roster[];

  beforeEach(() => {
    storeSettings = {
      minStaffPerShift: 3,
      maxStaffPerShift: 12,
      requireCoverageValidation: true,
      allowOverlap: false,
      defaultShiftDuration: 9,
      weekStartDay: 1,
      enableAuditLog: true,
      enableEmailNotifications: false,
      enableSlackNotifications: false,
      siPermissions: [],
      siCanDeleteStaff: true,
      siCanModifySM: false,
      siCanPublishRoster: false
    };

    allUsers = [
      {
        id: 'user-1',
        employeeId: 'PP001',
        firstName: 'Alex',
        lastName: 'Worker',
        email: 'alex@example.com',
        roleId: 'role-pp',
        storeId: 'store-1',
        experienceLevel: ExperienceLevel.EXPERIENCED,
        weekOffs: [0], // Sunday
        isActive: true,
        createdAt: new Date(),
        createdBy: 'system',
        updatedAt: new Date()
      }
    ];

    allRosters = [];
  });

  it('should validate roster with sufficient staff', () => {
    const roster: Roster = {
      id: 'roster-1',
      storeId: 'store-1',
      date: '2024-01-22', // Monday
      shiftType: ShiftType.MORNING,
      slots: [
        {
          id: 'slot-1',
          rosterId: 'roster-1',
          userId: 'user-1',
          shiftType: ShiftType.MORNING,
          date: '2024-01-22',
          assignedTasks: [],
          startTime: '08:00',
          endTime: '17:00',
          status: 'draft'
        }
      ],
      coverage: {
        totalSlots: 1,
        filledSlots: 1,
        vacantSlots: 0,
        coveragePercentage: 100,
        minRequiredStaff: 3,
        actualStaff: 1,
        warnings: []
      },
      status: 'draft',
      createdAt: new Date(),
      createdBy: 'user-1',
      updatedAt: new Date()
    };

    const result = validateRosterAssignments(roster, storeSettings, allUsers, allRosters);
    expect(result.valid).toBe(false);
    expect(result.errors.some(e => e.code === 'MIN_STAFF_NOT_MET')).toBe(true);
  });

  it('should detect week-off violations', () => {
    const roster: Roster = {
      id: 'roster-1',
      storeId: 'store-1',
      date: '2024-01-21', // Sunday
      shiftType: ShiftType.MORNING,
      slots: [
        {
          id: 'slot-1',
          rosterId: 'roster-1',
          userId: 'user-1',
          shiftType: ShiftType.MORNING,
          date: '2024-01-21',
          assignedTasks: [],
          startTime: '08:00',
          endTime: '17:00',
          status: 'draft'
        }
      ],
      coverage: {
        totalSlots: 1,
        filledSlots: 1,
        vacantSlots: 0,
        coveragePercentage: 100,
        minRequiredStaff: 3,
        actualStaff: 1,
        warnings: []
      },
      status: 'draft',
      createdAt: new Date(),
      createdBy: 'user-1',
      updatedAt: new Date()
    };

    const result = validateRosterAssignments(roster, storeSettings, allUsers, allRosters);
    expect(result.valid).toBe(false);
    expect(result.errors.some(e => e.code === 'WEEK_OFF_VIOLATION')).toBe(true);
  });

  it('should detect duplicate assignments', () => {
    const roster: Roster = {
      id: 'roster-1',
      storeId: 'store-1',
      date: '2024-01-22',
      shiftType: ShiftType.MORNING,
      slots: [
        {
          id: 'slot-1',
          rosterId: 'roster-1',
          userId: 'user-1',
          shiftType: ShiftType.MORNING,
          date: '2024-01-22',
          assignedTasks: [],
          startTime: '08:00',
          endTime: '17:00',
          status: 'draft'
        },
        {
          id: 'slot-2',
          rosterId: 'roster-1',
          userId: 'user-1',
          shiftType: ShiftType.MORNING,
          date: '2024-01-22',
          assignedTasks: [],
          startTime: '08:00',
          endTime: '17:00',
          status: 'draft'
        }
      ],
      coverage: {
        totalSlots: 2,
        filledSlots: 2,
        vacantSlots: 0,
        coveragePercentage: 100,
        minRequiredStaff: 3,
        actualStaff: 1,
        warnings: []
      },
      status: 'draft',
      createdAt: new Date(),
      createdBy: 'user-1',
      updatedAt: new Date()
    };

    const result = validateRosterAssignments(roster, storeSettings, allUsers, allRosters);
    expect(result.valid).toBe(false);
    expect(result.errors.some(e => e.code === 'DUPLICATE_ASSIGNMENT')).toBe(true);
  });
});

describe('canPerformAction', () => {
  const smRole: Role = {
    id: 'role-sm',
    name: 'Store Manager',
    permissions: Object.values(Permission),
    isEditable: false,
    isSystemRole: true,
    createdAt: new Date(),
    createdBy: 'system',
    updatedAt: new Date()
  };

  const siRole: Role = {
    id: 'role-si',
    name: 'Shift In Charge',
    permissions: [Permission.CRUD_USER, Permission.VIEW_OWN_STAFF],
    isEditable: true,
    isSystemRole: true,
    createdAt: new Date(),
    createdBy: 'system',
    updatedAt: new Date()
  };

  it('should allow SM to perform any action', () => {
    const smUser: User & { role?: Role } = {
      id: 'user-sm',
      employeeId: 'SM001',
      firstName: 'John',
      lastName: 'Manager',
      email: 'john@example.com',
      roleId: 'role-sm',
      storeId: 'store-1',
      experienceLevel: ExperienceLevel.EXPERIENCED,
      weekOffs: [],
      isActive: true,
      createdAt: new Date(),
      createdBy: 'system',
      updatedAt: new Date(),
      role: smRole
    };

    const result = canPerformAction(
      'user-sm',
      Permission.CRUD_USER,
      null,
      smUser
    );

    expect(result.allowed).toBe(true);
  });

  it('should prevent SI from modifying SM users', () => {
    const siUser: User & { role?: Role } = {
      id: 'user-si',
      employeeId: 'SI001',
      firstName: 'Mike',
      lastName: 'Supervisor',
      email: 'mike@example.com',
      roleId: 'role-si',
      storeId: 'store-1',
      experienceLevel: ExperienceLevel.EXPERIENCED,
      weekOffs: [],
      isActive: true,
      createdAt: new Date(),
      createdBy: 'system',
      updatedAt: new Date(),
      role: siRole
    };

    const smTargetUser: User & { role?: Role } = {
      id: 'user-sm-target',
      employeeId: 'SM002',
      firstName: 'Sarah',
      lastName: 'Director',
      email: 'sarah@example.com',
      roleId: 'role-sm',
      storeId: 'store-1',
      experienceLevel: ExperienceLevel.EXPERIENCED,
      weekOffs: [],
      isActive: true,
      createdAt: new Date(),
      createdBy: 'system',
      updatedAt: new Date(),
      role: smRole
    };

    const result = canPerformAction(
      'user-si',
      Permission.CRUD_USER,
      { type: 'user', id: 'user-sm-target' },
      siUser,
      smTargetUser
    );

    expect(result.allowed).toBe(false);
    expect(result.reason).toContain('cannot modify Store Manager');
  });
});

describe('canDeleteUser', () => {
  it('should prevent deleting the last SM', () => {
    const allUsers: (User & { role?: Role })[] = [
      {
        id: 'user-sm-1',
        employeeId: 'SM001',
        firstName: 'John',
        lastName: 'Manager',
        email: 'john@example.com',
        roleId: 'role-sm',
        storeId: 'store-1',
        experienceLevel: ExperienceLevel.EXPERIENCED,
        weekOffs: [],
        isActive: true,
        createdAt: new Date(),
        createdBy: 'system',
        updatedAt: new Date(),
        role: {
          id: 'role-sm',
          name: 'Store Manager',
          permissions: [],
          isEditable: false,
          isSystemRole: true,
          createdAt: new Date(),
          createdBy: 'system',
          updatedAt: new Date()
        }
      }
    ];

    const result = canDeleteUser(
      'user-sm-1',
      'user-sm-1',
      allUsers,
      [],
      undefined
    );

    expect(result.allowed).toBe(false);
    expect(result.reason).toContain('last Store Manager');
  });

  it('should identify impacted rosters for future assignments', () => {
    const today = new Date();
    const futureDate = new Date(today);
    futureDate.setDate(futureDate.getDate() + 5);

    const allUsers: (User & { role?: Role })[] = [
      {
        id: 'user-1',
        employeeId: 'PP001',
        firstName: 'Alex',
        lastName: 'Worker',
        email: 'alex@example.com',
        roleId: 'role-pp',
        storeId: 'store-1',
        experienceLevel: ExperienceLevel.EXPERIENCED,
        weekOffs: [],
        isActive: true,
        createdAt: new Date(),
        createdBy: 'system',
        updatedAt: new Date()
      }
    ];

    const allRosters: Roster[] = [
      {
        id: 'roster-1',
        storeId: 'store-1',
        date: futureDate.toISOString().split('T')[0],
        shiftType: ShiftType.MORNING,
        slots: [
          {
            id: 'slot-1',
            rosterId: 'roster-1',
            userId: 'user-1',
            shiftType: ShiftType.MORNING,
            date: futureDate.toISOString().split('T')[0],
            assignedTasks: [],
            startTime: '08:00',
            endTime: '17:00',
            status: 'draft'
          }
        ],
        coverage: {
          totalSlots: 1,
          filledSlots: 1,
          vacantSlots: 0,
          coveragePercentage: 100,
          minRequiredStaff: 3,
          actualStaff: 1,
          warnings: []
        },
        status: 'draft',
        createdAt: new Date(),
        createdBy: 'user-1',
        updatedAt: new Date()
      }
    ];

    const result = canDeleteUser(
      'user-1',
      'user-sm-1',
      allUsers,
      allRosters,
      undefined
    );

    expect(result.allowed).toBe(true);
    expect(result.impactedRosters.length).toBe(1);
    expect(result.canReassign).toBe(true);
  });
});

describe('canDeleteRole', () => {
  it('should prevent deleting role with assigned users', () => {
    const allRoles: Role[] = [
      {
        id: 'role-pp',
        name: 'Picker Packer',
        permissions: [],
        isEditable: true,
        isSystemRole: false,
        createdAt: new Date(),
        createdBy: 'system',
        updatedAt: new Date()
      }
    ];

    const allUsers: User[] = [
      {
        id: 'user-1',
        employeeId: 'PP001',
        firstName: 'Alex',
        lastName: 'Worker',
        email: 'alex@example.com',
        roleId: 'role-pp',
        storeId: 'store-1',
        experienceLevel: ExperienceLevel.EXPERIENCED,
        weekOffs: [],
        isActive: true,
        createdAt: new Date(),
        createdBy: 'system',
        updatedAt: new Date()
      }
    ];

    const result = canDeleteRole('role-pp', allRoles, allUsers);
    expect(result.allowed).toBe(false);
    expect(result.affectedUsers.length).toBe(1);
  });

  it('should prevent deleting system roles', () => {
    const allRoles: Role[] = [
      {
        id: 'role-sm',
        name: 'Store Manager',
        permissions: [],
        isEditable: false,
        isSystemRole: true,
        createdAt: new Date(),
        createdBy: 'system',
        updatedAt: new Date()
      }
    ];

    const result = canDeleteRole('role-sm', allRoles, []);
    expect(result.allowed).toBe(false);
    expect(result.reason).toContain('System roles cannot be deleted');
  });
});

describe('validateEmail', () => {
  it('should validate correct email addresses', () => {
    expect(validateEmail('user@example.com').valid).toBe(true);
    expect(validateEmail('user.name@example.co.uk').valid).toBe(true);
  });

  it('should reject invalid email addresses', () => {
    expect(validateEmail('invalid-email').valid).toBe(false);
    expect(validateEmail('@example.com').valid).toBe(false);
    expect(validateEmail('user@').valid).toBe(false);
  });
});

describe('validateEmployeeId', () => {
  it('should detect duplicate employee IDs', () => {
    const existingUsers: User[] = [
      {
        id: 'user-1',
        employeeId: 'PP001',
        firstName: 'Alex',
        lastName: 'Worker',
        email: 'alex@example.com',
        roleId: 'role-pp',
        storeId: 'store-1',
        experienceLevel: ExperienceLevel.EXPERIENCED,
        weekOffs: [],
        isActive: true,
        createdAt: new Date(),
        createdBy: 'system',
        updatedAt: new Date()
      }
    ];

    const result = validateEmployeeId('PP001', existingUsers);
    expect(result.valid).toBe(false);
    expect(result.errors[0].code).toBe('EMPLOYEE_ID_DUPLICATE');
  });

  it('should allow unique employee IDs', () => {
    const existingUsers: User[] = [
      {
        id: 'user-1',
        employeeId: 'PP001',
        firstName: 'Alex',
        lastName: 'Worker',
        email: 'alex@example.com',
        roleId: 'role-pp',
        storeId: 'store-1',
        experienceLevel: ExperienceLevel.EXPERIENCED,
        weekOffs: [],
        isActive: true,
        createdAt: new Date(),
        createdBy: 'system',
        updatedAt: new Date()
      }
    ];

    const result = validateEmployeeId('PP002', existingUsers);
    expect(result.valid).toBe(true);
  });
});

describe('validateWeekOffs', () => {
  it('should validate week-off day numbers', () => {
    expect(validateWeekOffs([0, 6]).valid).toBe(true);
    expect(validateWeekOffs([1, 2, 3]).valid).toBe(true);
  });

  it('should reject invalid day numbers', () => {
    const result = validateWeekOffs([7, 8]);
    expect(result.valid).toBe(false);
    expect(result.errors[0].code).toBe('INVALID_WEEK_OFF_DAYS');
  });

  it('should detect duplicate week-offs', () => {
    const result = validateWeekOffs([0, 0, 6]);
    expect(result.valid).toBe(false);
    expect(result.errors[0].code).toBe('DUPLICATE_WEEK_OFFS');
  });
});

// ============================================================================
// E2E Test Scenario (using Playwright/Cypress syntax)
// ============================================================================

describe('E2E: SM creates role → bulk imports users → assigns roster → publishes', () => {
  it('should complete full workflow', async () => {
    // 1. Login as SM
    // await page.goto('/login');
    // await page.fill('[name="email"]', 'john.manager@example.com');
    // await page.fill('[name="password"]', 'password');
    // await page.click('button[type="submit"]');
    // await expect(page).toHaveURL('/dashboard');

    // 2. Create role
    // await page.goto('/roles');
    // await page.click('text=Create Role');
    // await page.fill('[name="name"]', 'Temp PP');
    // await page.selectOption('[name="permissions"]', ['VIEW_ROSTER']);
    // await page.click('text=Create');
    // await expect(page.locator('text=Temp PP')).toBeVisible();

    // 3. Bulk import users
    // await page.goto('/users');
    // await page.click('text=Bulk Import');
    // await page.fill('textarea', 'PP-ADHOC-001,Sam,Temp,sam@example.com,,role-temp-pp,fresher,adHoc,0,morning');
    // await page.click('text=Import');
    // await expect(page.locator('text=Sam Temp')).toBeVisible();

    // 4. Create roster
    // await page.goto('/roster');
    // await page.fill('[name="date"]', '2024-01-25');
    // await page.selectOption('[name="shift"]', 'morning');
    // await page.click('text=Assign Staff');
    // await page.click('text=Sam Temp');
    // await page.click('text=Publish Roster');
    // await expect(page.locator('text=Roster published successfully')).toBeVisible();
  });
});
